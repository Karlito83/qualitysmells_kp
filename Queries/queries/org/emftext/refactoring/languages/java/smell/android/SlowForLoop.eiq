package org.emftext.refactoring.languages.java.smell.android

import "http://www.emftext.org/java/classifiers";
import "http://www.emftext.org/java/references";
import "http://www.emftext.org/java/commons";
import "http://www.emftext.org/java/types";
import "http://www.emftext.org/java/variables";
import "http://www.emftext.org/java/expressions";
import "http://www.emftext.org/java/statements";
import "http://www.emftext.org/java/generics"


pattern test(a,b,c) {
	Class.^extends(a,b);
	ClassifierReference.target(b,c);
	Classifier.name(c, "Iterable");
}

pattern allImplementorsOfList(a) {
	Interface.name(interfaceReference, "List");
	ClassifierReference.target(ClassifierReference, interfaceReference);
	Class.^implements(actualClass, ClassifierReference);
	Class.name(actualClass, a);
	
	//Interface.
	//TypedElement.typeReference(actualInterface, a);
}

pattern forLoopCondition(a){
	ForLoop.condition(forLoopRef,a);
	RelationExpression(a);
}

pattern InterfaceTypeParametersTest(a){
	Interface.name(actualInterface, "List");
	ClassifierReference.target(a,actualInterface);
	//Variable
}

pattern iterableVariable(a,b){
	Variable(a);
	Variable.name(a, "test");
	Variable.typeReference(a, ref);
	NamespaceClassifierReference.classifierReferences(ref,ref2);
	ClassifierReference.target(ref2, b);
	
	ClassifierReference.target(ref2,actualInterface);
	find implementorOfIterable(actualInterface);
	
	//ClassifierReference.target(ref,b);
	//Interface.typeParameters()
}

pattern implementorOfIterable(a){
	Interface.name(actualInterface, "Iterable");
	find ImplementsOrExtends+(a,actualInterface);
}

pattern extendsControl(a){
	Class.name(actualClass, "Control");
	find ImplementsOrExtends+(a, actualClass);
}

pattern ImplementsOrExtends(a,b){
	Interface.^extends(a, classifierRef);
	ClassifierReference.target(classifierRef, b);
	//Interface(b);Variable.typeReference(a, typeReference);
} or {
	Class.implements(a, classifierRef);
	ClassifierReference.target(classifierRef, b);
}