package org.emftext.refactoring.languages.java.smell.android

import "http://www.emftext.org/java/classifiers";
import "http://www.emftext.org/java/references";
import "http://www.emftext.org/java/commons";
import "http://www.emftext.org/java/types";
import "http://www.emftext.org/java/variables";
import "http://www.emftext.org/java/expressions";
import "http://www.emftext.org/java/statements";
import "http://www.emftext.org/java/generics";
import "http://www.emftext.org/java/literals";


pattern allImplementorsOfList(a) {
	Interface.name(interfaceReference, "List");
	ClassifierReference.target(ClassifierReference, interfaceReference);
	Class.^implements(actualClass, ClassifierReference);
	Class.name(actualClass, a);
	
	//Interface.
	//TypedElement.typeReference(actualInterface, a);
}

pattern forLoop(a){
	ForLoop(a);
}


pattern forLoopCondition(a){
	//ForLoop(a);
	ForLoop.condition(a,conditionRef);
	RelationExpression.children(conditionRef,childRef);
	IdentifierReference.target(childRef, b);
	find iterableVariable(b);
	IdentifierReference.next(childRef, methCallRef);
	//MethodCall.target.name(methCallRef, "size");
}

pattern InterfaceTypeParametersTest(a){
	Interface.name(actualInterface, "List");
	ClassifierReference.target(a,actualInterface);
	//Variable
}

pattern iterableVariable(a){
	Variable(a);
	Variable.typeReference(a, ref);
	NamespaceClassifierReference.classifierReferences(ref,ref2);
	ClassifierReference.target(ref2,actualInterface);
	find implementorOfIterable(actualInterface);	
}

pattern implementorOfIterable(a){
	Interface.name(actualInterface, "Iterable");
	find implementsOrExtends+(a,actualInterface);
}

pattern implementsOrExtends(a,b){
	Interface.^extends(a, classifierRef);
	ClassifierReference.target(classifierRef, b);
	//Interface(b);Variable.typeReference(a, typeReference);
} or {
	Class.implements(a, classifierRef);
	ClassifierReference.target(classifierRef, b);
}